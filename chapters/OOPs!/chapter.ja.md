# Ooops!= オブジェクト指向プログラミングとクラス

_by [Rui Pereira](http://www.rux-werx-here.net/)_

## 概要

このチュートリアルはopenFrameworksにおけるオブジェクト指向プログラミングの手短で実践的なチュートリアルであり、独自のクラスを作成して利用するためのハウトゥ・ガイドです。
このチャプターを終わる頃には、独自のオブジェクトの作成方法を理解し、画面にたくさんのボールを出せていることでしょう！

![ボールのスクリーンショット](images/balls_screenshot.png "ボールのスクリーンショット")

## オブジェクト指向プログラミングとは何か

オブジェクト指向プログラミング（Object-Oriented Programming、OOP）はオブジェクトの利用と相互作用を基礎としたプログラミング・パラダイムです。よく言われる例えは、「クラス」とはクッキーの型抜きで、それによりたくさんのクッキー（オブジェクト）を作成できるというものです。
OOPで使われる用語と定義のいくつかを以下に挙げます。

- クラスは物（オブジェクト）の特徴や振る舞いを定義します。プロパティや属性だけでなく、なにができるかについても定義します。

- オブジェクトとはクラスのインスタンスです。

- メソッドはそのオブジェクトが出来ることです。

## 独自クラスの作成方法（シンプルなクラス）

クラスとオブジェクトはオブジェクト指向プログラミングにおける基本的なパーツです。
コーディングと同じように料理は楽しいですし、キッチンで実際に試すこともできるので、引き続き古くからのクッキー型とクラス、およびクッキーとオブジェクトの例えを使い、その相互作用、能力や振る舞いを定義していきましょう。
あらゆるクラスは2つのファイルからなります。末尾が'.h'のヘッダファイル、定義ファイルとも呼ばれるものと、'.cpp'で終わる実装ファイルです。
この2つのファイルが何をしているかを理解するには、ヘッダファイル（.h）をクッキーの主な材料を書き出したレシピと考えると簡単です。実装ファイル（.cpp）はそれらをどうするか、どんな風に混ぜ合わせて、どんな風にすれば完璧なクッキーになるかです！
さて、どのように動作するかみていきましょう。

まず始めに、クラスの2つのファイルを作成しましょう。
IDE（統合開発環境のことです）としてXcodeを使っている場合、srcフォルダーを選択して左クリック（またはCTRL＋クリック）し、ポップアップメニューで'New File'を選択すると新しいウインドウメニューが開きますので、開発対象の適切なプラットフォーム（OS XかiOS）とC++クラスを選択して、最後に名前を選択します。私は'Ball'としました。
'src'フォルダーの中に、'Ball.h'と'Ball.cpp'という2つのファイルが自動的に作成されると思います。
Code::Blocksを使用している場合、"exapmles"ディレクトリーの中の空のものから新規プロジェクトを作成します。もしくは、ProjectGeneratorを参照してください。"empty"のフォルダーをコピーして、名前を"OOP"に変更しましょう。この新しいディレクトリーに移動し、"emptyExample"をコピーして名前を"ball1"に変更します。"ball1"ディレクトリーの中で、"emptyExample.workspace"を"ball1.workspace"に、"emptyExample.cbp"を"ball1.cbp"という風に変更します。これで作業するための専用のディレクトリーとプロジェクトの作成ができました。Code::Blocksで"ball1.cbp"を開き、"emptyExample"ワークスペースを右クリックして"Properties"（リストの最後の項目）を選択し、プロジェクトのタイトルを変更しましょう。このチャプターで編集するすべてのファイルはプロジェクトの"src"ディレクトリーの中に含まれています。'src'ディレクトリーの中に2つの新規ファイルを作成します。これは'File'->'New'->'Empty File'かTab+Ctrl+Nを押下することで行えます。一つは'Ball.h'、もう一つは'Ball.cpp'という名前にしましょう。
さて、クラスのヘッダー（.h）ファイルを編集していきましょう。中のものは気にせずすべて削除してしまって、まっさらな状態から始めましょう。ヘッダーファイル（.h）の中でクラスを宣言します。今回は、ファイル名はBall.hである必要があります。
下記のコードを追いながらBall.hファイルに記入していきます。中に書いてある説明書きにも注意してください。

```cpp
#ifndef _BALL // もしこのクラスが定義されていなければ定義します。
#define _BALL // これのif宣言により、クラスが複数回コールされてコンパイラーが混乱することを防止します。
#include "ofMain.h" // これはopenFrameworksフレームワークを参照できるように追加しています。
class Ball {

    public: // public関数や変数の宣言をここに記述します。

    // メソッドはクラスオブジェクトに固有の関数と同じものです。
    void setup();    // setupメソッド。オブジェクトの初期状態の設定に利用します。
    void update();  // updateメソッド。オブジェクトのプロパティーの更新に利用します。
    void draw();    // drawメソッド。オブジェクトの描画に利用します。

    // 変数
    float x;        // 位置
    float y;
    float speedY;   // 速度と方向
    float speedX;
    int dim;        // サイズ
    ofColor color;  // 色。ofColor型を使います

    Ball();  // コンストラクタ。オブジェクトの初期化に利用します。プログラムに何もプロパティーが渡されなければデフォルト値に設定されます。
    private: // private関数や変数の宣言はここに記述します。
}; // セミコロンを忘れずに！
#endif
```

Ballクラスのヘッダーファイル（材料のリスト）を宣言しましたので、調理パートに取り掛かってこれらの材料で何ができるかを見ていきましょう！
'#include'タグに着目してください。これで[コンパイラ](http://www.cplusplus.com/doc/tutorial/introduction/ "Compiler introduction on cplusplus.com") ([wikipedia](https://en.wikipedia.org/wiki/Compiler "Wikipedia on compilers"))に対して、実装ファイルにインクルードするファイルについて伝えています。プログラムがコンパイルされる際、この'#include'タグはそれが参照しているオリジナルのファイルに置き換えられます。
この'ifステートメント'（#ifndef）により、安易にヘッダーファイルが繰り返されることを防止しています。これは[includeガード](https://en.wikipedia.org/wiki/Include_guard "Wikipedia on include guards")と呼ばれます。このパターンにより、コンパイラーがファイルを一度だけincudeして重複をしないようにしています。これについては今は気にせず、続きは後ほどお話ししましょう！

ボールオブジェクトのためのクラスを作成していきましょう。このボールは色（color）、速度（speed）と方向（direction）プロパティーを持っています。画面中を動いて、壁で跳ね返ります。これらのプロパティーのいくつかはランダムな属性値で作成しますが、動きの振る舞いの正しいロジックを作成する必要があります。

Ball.cpp実装ファイルは以下のように記述します。

```cpp
#include "Ball.h"
Ball::Ball(){
}

void Ball::setup(){
    x = ofRandom(0, ofGetWidth());      // ランダムな位置を与えます。
    y = ofRandom(0, ofGetHeight());

    speedX = ofRandom(-1, 1);           // ランダムな速度と方向を与えます。
    speedY = ofRandom(-1, 1);

    dim = 20;

    color.set(ofRandom(255),ofRandom(255),ofRandom(255)); // デジタルに色を定義する方法の一つは、3つの色の要素（赤、緑、青）をそれぞれ、0-255の値で指定します。この例ではそれぞれをランダムな値に設定しています。
}

void Ball::update(){
    if(x < 0 ){
        x = 0;
        speedX *= -1;
    } else if(x > ofGetWidth()){
        x = ofGetWidth();
        speedX *= -1;
    }

    if(y < 0 ){
        y = 0;
        speedY *= -1;
    } else if(y > ofGetHeight()){
        y = ofGetHeight();
        speedY *= -1;
    }

    x+=speedX;
    y+=speedY;
}

void Ball::draw(){
    ofSetColor(color);
    ofDrawCircle(x, y, dim);
}
```

これはとてもシンプルなプログラムなので、ofAppファイル（.hと.cpp）の中にも記述ができ、このコードを他の場所で再利用しようとしなければそれで意味のあるものでしょう。オブジェクト指向プログラミングのメリットの一つは再利用性にあります。このボールを数千個作成することを想像してください。OOPを用いなければそのコードは用意に煩雑になってしまうでしょう。独自のクラスを作成することで、コードをクリーンで効率的に保ったまま、そこから必要なだけのオブジェクトを再生成したり、必要な時に適切なメソッドを呼び出すだけといったことが可能です。より実践的な例として、ユーザーインターフェース（UI）要素（ボタン、スライダー等）のためのクラスを作成してプログラムにデプロイし、さらに将来のプログラムで再利用することがいかに容易かを想像してください。

## クラスからオブジェクトを作成する

これでクラスを作成できましたので、実際にオブジェクトを作ってみましょう！ofApp.h（ヘッダーファイル）の中で新しいオブジェクトを宣言する必要がありますが、まずはBallクラスをプログラムにincludeする（またはそのような命令を与える）必要があります。これをするには以下、

```cpp
#include "Ball.h"
```

をofApp.hファイルの先頭に記述します。これでようやくプログラムの中でクラスのインスタンスを宣言することができます。下記の行を`ofApp`クラスの中に、最後の"};"の直前に追記します。

```cpp
Ball myBall;
```

さて、このボールを画面上で跳ね回らせましょう！プロジェクトのofApp.cpp（実装ファイル）を開きます。これでオブジェクトを作成できましたので、あとはこれを設定して、メソッドを呼ぶことで値の更新と描画を行えば良いです。

ofApp.cppの`setup()`関数に以下のコードを追記します。

```cpp
myBall.setup(); // オブジェクトのsetupメソッドを呼びます。
```

`update()`関数の中には以下を追加します。

```cpp
myBall.update(); // オブジェクトのupdateメソッドを呼びます。
```

そして`draw()`関数には以下を加えましょう。

```cpp
myBall.draw(); // オブジェクトの描画のためにdwarメソッドを呼びます。
```

コンパイルして、実行しましょう！この時点で、画面にはバウンドするボールが表示されているはずです！良いでしょう！

## クラスからオブジェクトを作成する

これまで、なぜバウンドするボールを作成するのにこんなに苦労しなければいけないのかと疑問に思ったことでしょう。これはクラスを用いなくても実現できた（あるいはすでにそうしたことがある）かもしれません。実は、クラスを利用する利点の一つは、同じ特徴をもったオブジェクトを、独立して複数作成することが可能な点にあります。さっそくやってみましょう！ofApp.hファイルに戻って、オブジェクトを2つ新規に作成しましょう。

```cpp
Ball myBall1;
Ball myBall2;
Ball myBall3;
```

実装ファイル(ofApp.cpp)の中で、各々のオブジェクトに対して同じメソッドを呼び出します。
ofAppの`setup()`関数は以下のようになります。

```cpp
myBall1.setup();
myBall2.setup();
myBall3.setup();
```

ofAppの`update()`関数の中は以下です。

```cpp
myBall1.update();
myBall2.update();
myBall3.update();
```

同様に`draw()`関数です。

```cpp
myBall1.draw();
myBall2.draw();
myBall3.draw();
```

## クラスからさらにオブジェクトを作成する

さきほど3つのオブジェクトを作成しましたが、これを10、100または1000個も作るとなるといかに面倒かがお分かりいただけていることでしょう。一つずつハードコーディングすることは時間がかかって苦痛な作業なのですが、オブジェクトの作成や関数コールは簡単に自動化して解決できます。2つのforループを使うことで、この作業をシンプルで明快にしていきましょう。一つずつオブジェクトを宣言する代わりに、`Ball`型のオブジェクトの配列を作成します。ここで、新しい要素である「定数（Constants）」も紹介しましょう。定数（Constants）は#includesの後に#define 定数名 値として設定されます。これはプログラムの中でずっと変化しない値を設定する方法です。
ofAppクラスのヘッダファイル中、Ballオブジェクトを定義する箇所で、オブジェクトの数として利用する定数も定義できます。

```cpp
#define NBALLS 10
```

NBALLSという定数の値を、オブジェクトの配列のサイズの定義に利用します。

```cpp
Ball groupOfBalls[NBALLS];
```

配列は、同じ型を持つ要素の添字付きのリストです。添字はリスト中の特定の要素にアクセスするために用いられます。添字は通常0から始まりますので、先頭の`Ball`（オブジェクト）はgroupOfBalls[0]にあります。ごくわずかなプログラミング言語においては、添字は1から始まるものもあります。不正な添字（配列のサイズよりも大きいか、負の値）にアクセスしようとするとエラーになります。配列についてより詳しくは、'C++ basics'の章をご覧ください。実装ファイルの中で、オブジェクトの配列とメソッドの呼び出しを'for'ループを使って行っていきましょう。

`setup()`関数から以下を削除します。

```cpp
myBall1.setup();
myBall2.setup();
myBall3.setup();
```

そして、

```cpp
for(int i=0; i<NBALLS; i++){
    groupOfBalls[i].setup();
}
```

上記を追加します。

`update()`関数は以下を削除して、

```cpp
myBall1.update();
myBall2.update();
myBall3.update();
```

そして、以下の記述にします。

```cpp
for(int i=0; i<NBALLS; i++){
    groupOfBalls[i].update();
}
```

`draw()`関数では下記を、

```cpp
myBall1.draw();
myBall2.draw();
myBall3.draw();
```

以下のように置き換えます。with

```cpp
for(int i=0; i<NBALLS; i++){
    groupOfBalls[i].draw();
}
```

forループを使用することで、`setup()`、`update()`そして`draw()` メソッドは`myBall`配列の中のそれぞれの`Ball`オブジェクトに対して呼ばれ、オブジェクトを直接操作しなくてよくなりました。

## クラスからさらに多くのオブジェクトを作成する：プロパティーとコンストラクタ

これまで見てきたように、それぞれのオブジェクトはその変数（位置、速度、方向、大きさ）として定義されたプロパティを保持しています。オブジェクト指向プログラミングのもう一つの利点は、作成されたオブジェクトがそれぞれプロパティとして別々の値を持つことができるという点です。個々のオブジェクトをよりよく制御するために、これらの特徴を定義し、アクセス可能にするための方法があります。これはオブジェクトを作成したすぐ後に行いたいので、`setup()`メソッドの中で行いましょう。オブジェクトのプロパティのいくつかを渡すことで調整していきます。位置と大きさにしましょう。まず、これを定義ファイル（\*.h）で行います。

```cpp
void setup(float _x, float _y, int _dim);
```

Ballの実装ファイル（\*.cpp）にもこの変更を反映させます。

```cpp
void Ball::setup(float _x, float _y, int _dim){
    x = _x;
    y = _y;
    dim = _dim;

    speedX = ofRandom(-1, 1);
    speedY = ofRandom(-1, 1);
}
```

これでBall.cppファイルは以下のようになりました。

```cpp
#include "Ball.h"

Ball::Ball(){
};

void Ball::setup(float _x, float _y, int _dim){
    x = _x;
    y = _y;
    dim = _dim;

    speedX = ofRandom(-1, 1);
    speedY = ofRandom(-1, 1);

    color.set(ofRandom(255), ofRandom(255), ofRandom(255));
}

void Ball::update(){
    if(x < 0 ){
        x = 0;
        speedX *= -1;
    } else if(x > ofGetWidth()){
        x = ofGetWidth();
    speedX *= -1;
    }

    if(y < 0 ){
        y = 0;
        speedY *= -1;
    } else if(y > ofGetHeight()){
        y = ofGetHeight();
        speedY *= -1;
    }

    x+=speedX;
    y+=speedY;
}

void Ball::draw(){
    ofSetColor(color);
    ofDrawCircle(x, y, dim);
}
```

次にofApp.cppファイルの中でアプリケーションが開始された直後にこの新しく実装したメソッドが実行され、オブジェクトが生成される際に異なった設定が反映されるようにしてみましょう。それでは、`ofApp::setup()`の中で

```cpp
for(int i=0; i<NBALLS; i++){

    int size = (i+1) * 10; // 配列の位置に基づいて各々のボールのサイズを設定します
    int randomX = ofRandom( 0, ofGetWidth() ); //0よりも大きくアプリケーションの画面幅よりも小さいランダムな値を生成します
    int randomY = ofRandom( 0, ofGetHeight() ); //0よりも大きくアプリケーションの画面の高さよりも小さいランダムな値を生成します

    groupOfBalls[i].setup(randomX, randomY, size);
}
```

お分かりのように、作成の際にオブジェクトのプロパティを直接操作することが可能になっています。これで、先頭から順番にforループを使い、ボールの更新と描画をそれぞれの関数を利用して行えばよくなりました。

```cpp
groupOfBalls[i].update();

groupOfBalls[i].draw();
```

## その場でオブジェクトを作成する

多くの場合、あらかじめ定義された数のオブジェクトがあって配列を利用することは正しい選択ですが、複数のオブジェクトを作成する別のやり方、vectorもあります！
vectorは、既定の要素数を持たずにオブジェクトの集合を作成することができる点で優れています。これはとても動的に、その場で（例えばプログラムの実行中に）オブジェクトを追加したり、必要のなくなったオブジェクトを削除することが可能です。これは伸縮する配列のようなものと考えてください。
さて使ってみましょう！
注意：このブックを通して2種類の異なるvectorに触れることになります。stl::vectors (今説明している、伸縮する配列)と数学上のvector (例えば力（force）)を混同しないでください。

stl::vectorについてさらに学ぶには、[short online tutorial on the openFrameworksのウェブサイトのオンラインチュートリアル](http://openframeworks.cc/tutorials/c++%20concepts/001_stl_vectors_basic.html)の"C++ basics"の章をご覧ください。

愛すべきofApp.hファイルを開き、`Ball`オブジェクトのvectorを定義しましょう。以下のように打ち込みます。

```cpp
vector <Ball> groupOfBalls;
```

この記述で、Ballポインタ型を持つvector型を作詞し、これをgroupOfBallsと名付けました。
さて、ofApp.cppを開いて作業に取り掛かりましょう！
とりあえずofAppの中の`setup()`、`update()`および`draw()`メソッドは無視して、`ofApp::mouseDragged(...)`メソッドにいきましょう。このメソッドは常時マウスのドラック操作を監視していて、これが変化するとその値（位置とボタンの状態）を教えてくれます。

```cpp
void ofApp::mouseDragged(int x, int y, int button){
}
```

このメソッドでマウスのドラッグ動作を監視し、これを使ってインタラクションを作成しましょう！マウスをドラッグした際に`Ball`を生成しプログラムに追加するコードを書いていきましょう。
マウスやトラックパッドのドラッグ動作はありふれていて単純ですが正にジェスチャーデータの元であるので、これでインタラクションを作成しましょう！マウスをドラッグした際`Ball`を生成しプログラムに追加するコードを書いていきます。

```cpp
void ofApp::mouseDragged(int x, int y, int button){
    Ball tempBall;                            // Ballオブジェクトの作成
    tempBall.setup(x,y, ofRandom(10,40));    // 初期状態の設定
    groupOfBalls.push_back(tempBall);                // vectorに追加します
}
```

いくつか新しいポイントがあります。まず始めに一時的なオブジェクトを宣言しました。これは実際のオブジェクトに対するプレースホルダと考えてください。これをvectorの中に入れていきます！- 次にマウスドラッグの`x`と`y`座標をsetupの変数に指定して初期プロパティを定義します。その後、この一時オブジェクトをプレースホルダとして利用し、`Ball`オブジェクトをvectorに追加します。

updateとdrawメソッドに戻りましょう。配列の時に行ったようにvecrtorの中にあるオブジェクトをイテレーションしてupdateやdrawを行うための'forループ'を加えましょう。ですが今度はオブジェクトの最大数を保持する変数は宣言しません。代わりにvectorオブジェクトはそのサイズを知るのに便利な`size()`というメソッドを提供してくれています。
`update()`は以下、

```cpp
for (int i = 0; i<groupOfBalls.size(); i++) {
    groupOfBalls[i].update();
}
```

そして`draw()`は以下です。

```cpp
for (int i = 0 ; i<groupOfBalls.size(); i++) {
    groupOfBalls[i].draw();
}
```

これで、あらかじめ具体的な要素数を指定することなくvectorの中にあるオブジェクトを'for'ループでイテレーションすることができるようになりました。要素数は`size()`のおかげで都度調整されます。

## 好きなように生成と削除を行う - vectorの利用

上述のコードを実行すると、非常に短時間のうちに大量のballが生成されるだけでなく、画面上にあまりに多くのオブジェクトが存在するために、どこかの時点でシステムが重くなることに気づくと思います。先ほど触れたように、vectorは動的に要素の追加や削除ができる点で特別です。そこがミソです。vectorは伸縮するのです！
そこで、Ballが増えすぎる前にそれらを削除する方法も実装しましょう。

`ofApp::MousePressed(...)`が呼ばれた時に、vectorをループしてマウスの座標と任意の`Ball`の位置との距離を調べます。もしこの距離が`Ball`の半径よりも小さい場合、これをクリックしたとして削除させます。`vector.erase(...)`メソッドを利用しますので、イテレータ（`groupOfBalls.begin()`）を使用する必要があります。イテレータは大きなグループの特定の要素を指していて、その範囲の要素を走査することができます。パスやリンクのようなものと考えてください。今回の例ではこれは初期状態でvectorの先頭の要素への参照のショートカットですので、実際に削除したい要素（`i`）にアクセスするには`groupOfBalls.begin()+i`となります。

```cpp
for (int i =0; i < groupOfBalls.size(); i++) {
    float distance = ofDist(x,y, groupOfBalls[i].x, groupOfBalls[i].y); // oFのメソッドで2つの座標間の距離を調べられます

    if (distance < groupOfBalls[i].dim) {
        groupOfBalls.erase(groupOfBalls.begin()+i); // イテレータで、削除したいvectorの位置への参照を使います。
    }
}
```

全体を削除したい場合も必ずあるでしょうから、vectorはこのための非常に便利な`clear()`というメソッドもあります。
ご自由に各自で試してみてください！

```cpp
groupOfBalls.clear();
```

## 多態性（ポリモーフィズム、継承）の簡単な紹介

あなたは今OOPの実力を目の当たりにしています。クラスを作成してそこから即座に必要な数のオブジェクトを作成し、アプリケーションの要求に合わせて追加や削除を行います。ここで、ちょっと料理の喩えに戻ってみましょう（美味しそうですね！）。クッキーは同じクッキー型と生地を使っていても、違ったスプリンクルを使えばクッキー瓶に望みのバリエーションを加えることができますね！
これもまたOOPと継承の力なのです。これによって、ベースクラスを使い、クラスの振る舞いのいくつかを上書きすることで任意の振る舞いを追加し、わずかに異なる挙動のインスタンス／オブジェクトのサブセットを作成することができます。
これの素晴らしい点は再利用性です。スタート地点として親クラスを利用し、その機能の全てを使いながらメソッドの一つを上書きし、より柔軟性を与えてあげます。
最初のバージョンの`Ball`クラスに戻り、その主な機能（動きや形状）をベースにしながらいくつかの子クラスを作成し、それぞれのサブクラスの描画メソッドで異なる色をこと使うことで区別していきましょう。

Ballのヘッダファイルは以下のようになります。

```cpp
#ifndef _BALL // このクラスが定義されていなければ定義するようにします
#define _BALL // このifステートメントによりclassが複数回呼ばれることでコンパイラが混乱しないようにします。
#include "ofMain.h"


class Ball {
    public: // public関数や変数の宣言をここに記述します。

    void setup();
    void update();
    void draw();

    // 変数
    float x;
    float y;
    float speedY;
    float speedX;
    int dim;

    ofColor color;

    Ball();

    private:
};
#endif
```

実装ファイルに少し修正を加えていきましょう。ランダムなサイズの最小および最大値をより大きな値に変更し、位置を画面の中心に変更しましょう。ソースコードを下記のようにしてください。

```cpp
#include "Ball.h"

Ball::Ball(){
}

void Ball::setup(){

    x = ofGetWidth()*.5;
    y = ofGetHeight()*.5;
    dim = ofRandom(200,250);

    speedX = ofRandom(-1, 1);
    speedY = ofRandom(-1, 1);

    color.set(ofRandom(255), ofRandom(255), ofRandom(255));
}
```

`update()`と`draw()`関数はそのままにしておいて良いですが、ofApp.cppの`mouseDragged(...)`は新しい`setup()`関数に合わせて3つの引数を削除する必要があります。

```cpp
void ofApp::mouseDragged(int x, int y, int button){
    Ball tempBall;                // Ballオブジェクトの作成
    tempBall.setup();            // 初期状態の設定
    groupOfBalls.push_back(tempBall);    // vectorに追加します
}
```

さて、この親クラスの子供バージョンを作成していきましょう。
クラス用のファイル一式を新規作成して`BallBlue`と名付けましょう。下記のコードはご自由にコピーしてください。
'.h'ファイルはこのようになります。

```cpp
#pragma once                // このファイルが一回以上インクルードされないようにする別のよりモダンな方法です

#include "ofMain.h"
#include "Ball.h"            // コンパイラが親／ベースクラスをインクルードして継承した全てのメソッドにアクセスできるために親クラスをインクルードする必要があります。
class BallBlue : public Ball {     // このクラスが'Ball'から継承されるように設定します
    public:
        virtual void draw();       // 親クラスから実際に変更したいのはこのメソッドだけです
};
```

次に、'.cpp'の中でこの新しい`draw()`メソッドが親クラスのものからどのような違う挙動をするかを指定する必要があります。

```cpp
#include "BallBlue.h"

void BallBlue::draw(){
    ofSetColor(ofColor::blue);    // これは真っ青な色のショートカットです ;)
    ofDrawCircle(x, y, dim);
}
```

ここで新規に2つのクラスを作成しましょう。`BallBlue`と同じように`Ball`を元にして、`BallRed`と`BallGreen`を作ります。
'ofApp.h'に戻りましょう。新規に作成したクラスをインクルードして、それぞれ'ofApp.cpp'ファイルの中で一つずつインスタンスを作成しましょう。それらを初期化してその`update()`および`draw()`メソッドを呼び出します。ちょっとしたトリック！`draw()`メソッドを呼び出す直前、以下を呼んでみましょう。

```cpp
ofEnableBlendMode(OF_BLENDMODE_ADD);
```

これでアプリケーションの描画モードが加算ブレンドモードになります。より詳しくは"Graphics"の章をご覧ください。

この短いチュートリアルを楽しんでくれたらうれしいです！
お楽しみあれ！
